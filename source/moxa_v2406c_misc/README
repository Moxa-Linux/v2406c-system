
misc-da682c supported to access Programable LED, relay, DI/DO,
and on board uart interface on DA-682C series.

the driver is based on GPIO sysfs.

To use sysfs/gpio, you can write script to export/unexport

*** Manage GPIO from command line or script:

From the user level side this "operation" for reserve the GPIO is called "export" the GPIO. 
For make this export operation you simply need to echo the GPIO number you are interested to a special path as follow
(change XX with the GPIO number you need):

** Export Example:
#!/bin/sh
export_gpio() {
    local TARGET_GPIOCHIP=moxa-gpio
    local GPIOCHIP_NAME=gpiochip
    local GPIO_FS_PATH=/sys/class/gpio
    local GPIO_EXPORT="export"

    if [ x"$1" == x"unexport" ]; then
        GPIO_EXPORT="unexport"
    fi

    #
    # Export GPIOs
    #
    ls $GPIO_FS_PATH | grep $GPIOCHIP_NAME | while read -r chip ; do
        GPIO_LABEL=$(cat $GPIO_FS_PATH/$chip/label)
        if [[ "$GPIO_LABEL" != *"$TARGET_GPIOCHIP"* ]]; then
            continue
        fi

        pinstart=$(echo $chip | sed s/$GPIOCHIP_NAME/\\n/g)
        count=$(cat $GPIO_FS_PATH/$chip/ngpio)
        for (( i=0; i<${count}; i++ )); do
            echo $((${pinstart}+${i})) > $GPIO_FS_PATH/$GPIO_EXPORT 2>/dev/null
        done
    done
}

# export
export_gpio

# unexport
export_gpio unexport

** Set Example:
echo 1 > /sys/class/gpio/pled1/value
echo 0 > /sys/class/gpio/relay1/value

** Get Example:
cat /sys/class/gpio/pled1/value



*** Manage GPIO from application:
** Set Example:
sprintf(buf, "/sys/class/gpio/pled1/value", gpio);

fd = open(buf, O_WRONLY);

// Set GPIO high status
write(fd, "1", 1); 
// Set GPIO low status 
write(fd, "0", 1); 

close(fd);
